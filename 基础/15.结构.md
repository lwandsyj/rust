1. 结构的各个部分可以是不同的类型

        struct User {
            username: String,
            email: String,
            sign_in_count: u64,
            active: bool,
        }

2. 实例化结构

        let user1 = User {
            email: String::from("someone@example.com"),
            username: String::from("someusername123"),
            active: true,
            sign_in_count: 1,
        };

3. 获取结构中元素

   要从结构中获取特定值，我们可以使用点表示法

   user1.email = String::from("anotheremail@example.com");

4. 结构属性赋值简写

   当变量和字段具有相同名称时，使用字段初始化速记

        fn build_user(email: String, username: String) -> User {
            User {
                email, // 简写，同es6 一样
                username,
                active: true,
                sign_in_count: 1,
            }
        }
        因为email字段和email参数具有相同的名称，所以我们只需要编写email而不是email: email。

5. 结构扩展

          let user2 = User {
            email: String::from("another@example.com"),
            username: String::from("anotherusername567"),
            ..user1 // 结构扩展
         };

6. 在rust 中没有类，使用结构代替类，但是结构只能定义字段，没有方法，使用impl 实现来扩展方法

        struct Rectangle {
            width: u32,
            height: u32,
        }

        impl Rectangle { // 实现结构
   
            /*
            * 定义方法
            * 方法第一个参数必须为&self,代表结构实例，可以调用实例中的属性
            */
            fn area(&self) -> u32 {
                self.width * self.height
            }
        }

        impl Rectangle {
            fn area(&self) -> u32 {
                self.width * self.height
            }
            
            // 其他方法
            fn can_hold(&self, other: &Rectangle) -> bool {
                self.width > other.width && self.height > other.height
            }
        }


7. 关联函数，在结构中，但是第一个参数不是&self

        impl Rectangle {
            fn square(size: u32) -> Rectangle {
                // 默认最后不带分号的语句为返回值
                Rectangle {
                    width: size,
                    height: size,
                }
            }
        }

   关联函数使用 :: 语法调用

        let sq = Rectangle::square(3);
