1. 基础类型

>（1） 基础类型 int,float,bool,&str

        let x = 5;
        let y = x;

   我们大致可以猜到这在干什么：“将 5 绑定到 x；接着生成一个值 x 的拷贝并绑定到 y”。现在有了两个变量，x 和 y，都等于 5。这也正是事实上发生了的，因为整数是有已知固定大小的简单值，所以这两个 5 被放入了栈中。

   **注意**

   > ***基础类型是赋值了一份值给新变量，不影响原来的变量***

>(2) 复合类型

        let s1 = String::from("hello");
        let s2 = s1;

   这看起来与上面的代码非常类似，所以我们可能会假设他们的运行方式也是类似的：也就是说，第二行可能会生成一个 s1 的拷贝并绑定到 s2 上。***不过，事实上并不完全是这样***

   看看图 1 以了解 String 的底层会发生什么。String 由三部分组成，如图左侧所示：一个指向存放字符串内容内存的指针，一个长度，和一个容量。这一组数据存储在栈上。右侧则是堆上存放内容的内存部分。

   ![svg](../../assets/suoyouquan.svg)

   图 1：将值 "hello" 绑定给 s1 的 String 在内存中的表现形式

   长度表示 String 的内容当前使用了多少字节的内存。容量是 String 从操作系统总共获取了多少字节的内存。长度与容量的区别是很重要的，不过在当前上下文中并不重要，所以现在可以忽略容量。

   当我们将 s1 赋值给 s2，String 的数据被复制了，这意味着我们从栈上拷贝了它的指针、长度和容量。我们并没有复制指针指向的堆上数据。换句话说，内存中数据的表现如图 2 所示

   ![svg](../../assets/suoyouquan2.svg)

   图 2：变量 s2 的内存表现，它有一份 s1 指针、长度和容量的拷贝

   这个表现形式看起来 并不像 图 4-3 中的那样，如果 Rust 也拷贝了堆上的数据，那么内存看起来就是这样的。如果 Rust 这么做了，那么操作 s2 = s1 在堆上数据比较大的时候会对运行时性能造成非常大的影响。

   ![svg](../../assets/suoyouquan3.svg)

    图 3：另一个 s2 = s1 时可能的内存表现，如果 Rust 同时也拷贝了堆上的数据的话

   之前我们提到过当变量离开作用域后，Rust 自动调用 drop 函数并清理变量的堆内存。不过图 4-2 展示了两个数据指针指向了同一位置。这就有了一个问题：当 s2 和 s1 离开作用域，他们都会尝试释放相同的内存。这是一个叫做 ***二次释放（double free)的错误***，也是之前提到过的内存安全性 bug 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。

   为了确保内存安全，这种场景下 Rust 的处理有另一个细节值得注意。***与其尝试拷贝被分配的内存，Rust 则认为 s1 不再有效***，因此 Rust 不需要在 s1 离开作用域后清理任何东西。看看在 s2 被创建之后尝试使用 s1 会发生什么；这段代码不能运行：

            let s1 = String::from("hello");
            let s2 = s1;

            println!("{}, world!", s1);

   ![avatar](../../assets/suoyouquan5.jpg)

   如果你在其他语言中听说过术语 浅拷贝（shallow copy）和 深拷贝（deep copy），那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。不过因为 ***Rust同时使第一个变量无效了，这个操作被称为 移动（move），而不是浅拷贝***。上面的例子可以解读为 s1 被 移动 到了 s2 中。那么具体发生了什么，如图 4-4 所示。

   ![svg](../../assets/suoyuquan4.svg)

   图 4：s1 无效之后的内存表现

   这样就解决了我们的问题！因为***只有 s2 是有效的，当其离开作用域，它就释放自己的内存，完毕***。

   另外，这里还隐含了一个设计选择：***Rust 永远也不会自动创建数据的 “深拷贝”***。因此，任何 自动 的复制可以被认为对运行时性能影响较小。

2. 克隆

   如果我们 确实 需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 clone 的通用函数。第五章会讨论方法语法，不过因为方法在很多语言中是一个常见功能，所以之前你可能已经见过了。

   这是一个实际使用 clone 方法的例子：



        let s1 = String::from("hello");
        let s2 = s1.clone();

        println!("s1 = {}, s2 = {}", s1, s2);
   这段代码能正常运行，并且明确产生图 4-3 中行为，这里堆上的数据 确实 被复制了。

   当出现 clone 调用时，你知道一些特定的代码被执行而且这些代码可能相当消耗资源。你很容易察觉到一些不寻常的事情正在发生。

3. 基础类型自动克隆

    这里还有一个没有提到的小窍门。这些代码使用了整型并且是有效的，他们是示例 4-2 中的一部分：



        let x = 5;
        let y = x;

        println!("x = {}, y = {}", x, y);

   但这段代码似乎与我们刚刚学到的内容相矛盾：没有调用 clone，不过 x 依然有效且没有被移动到 y 中。

   原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效。换句话说，这里没有深浅拷贝的区别，所以这里调用 clone 并不会与通常的浅拷贝有什么不同，我们可以不用管它