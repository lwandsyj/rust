1. 变量的作用域

   变量的作用域为{}

   我们一般把变量从出生到死亡的整个阶段， 叫作一个变量的“生命
周期”。 

2. 变量的搜有权：

+ 每个值在Rust中都有一个变量来管理它， 这个变量就是这个值、 这
块内存的所有者；

+ 每个值在一个时间点上只有一个管理者；

+ 当变量所在的作用域结束的时候， 变量以及它代表的值将会被销
毁

3. 移动

        let s = String::from("hello");
        let s1 = s;
        println!("{}", s);

        在let s1=s； 语句中， 原本由s拥有的字符串已经转移给了s1这个变量。 所以， 后面继续使用s是不对的

        变量s1的生命周期则是从它声明开始，到函数结束。 而字符串本身， 由String::from函数创建出来， 到函数结束的时候就会销毁。 中间所有权的转换， 并不会将这个字符串本身重新销毁再创建。 在任意时刻， 这个字符串只有一个所有者， 要么是s，要么是s1

        只是rust 和其他语言不通的地方

> 移动情况： 赋值语句、 函数调用、 函数返回

> Rust中的变量绑定操作， 默认是move语义， 执行了新的变量绑定后， 原来的变量就不能再被使用！

4. 复制

对于简单数据类型，int，bool，float,char,&str 等，默认是复制，不是移动

        let v2=v1； 等效于let v2=v1.clone（）

        let v1 : isize = 0;
        let v2 = v1;
        println!("{}", v1);

 因为在Rust中有一部分“特殊照顾”的类型， 其变量绑定操作是copy
语义。 所谓的copy语义， 是指在执行变量绑定操作的时候， v2是对v1所
属数据的一份复制。 v1所管理的这块内存依然存在， 并未失效， 而v2是
新开辟了一块内存， 它的内容是从v1管理的内存中复制而来的。 和手动
调用clone方法效果一样， let v2=v1； 等效于let v2=v1.clone（） 

5. 借用

   这个所有权不仅可以被转移（move） ， 还可以被借用（borrow） 

   借用指针的语法***使用&符号或者&mut符号***表示。 
   
   + &表示只读借用， 

   + &mut表示可读写借用。

6. 借用规则

+ &mut型借用只能指向本身具有mut修饰的变量， 对于只读变量，
不可以有&mut型借用。

+ &mut型借用指针存在的时候， 被借用的变量本身会处于“冻结”状
态。

+ 如果只有&型借用指针， 那么能同时存在多个； 如果存在&mut型
借用指针， 那么只能存在一个； 如果同时有其他的&或者&mut型借用指
针存在， 那么会出现编译错误

        let mut i=2;
        let b= &mut i;

        i 为i32 类型，
        b 为&i32 类型，两个不是相同的类型

> 当发生借用是，类型变成&T 类型，不能直接使用值，如果要使用值，则需要解引用

> 当一个变量被借用，在规划前不可用

        let mut x = 5;
        {
            let y =&mut x;
            *y += 1;
        }
        println!("{}", x);

 人好奇说，y不是不可变的吗？怎么能修改它的值呢？这里需要说明一下，y的确是不可变的，这里的不可变指的是y本身是不可变的，也就是说y只能指向x而不能修改成其他的引用，就像这样y = &mut z这是不允许的，因为y引用的是x的资源，x是可变的，*y += 1;就相当于 x += 1;这里是可变的，y自始自终指向的都是x。

 那为什么中间的两句代码要用{}括起来的，在C语言中{}是用来表示语句块的，从而限制变量的作用域，***在Rust中也是这样，一旦离开{}，那么y就超出了它的作用域***,又因为y是引用的x，相当于y从x那里借来（borrow）的资源，现在y使用完了，那么所有权就得重新回到了x上，所以最后一句输出代码才能正确调用，如果去掉{}，则会给出以下错误：

        error: cannot borrow `x` as immutable because it is also borrowed as mutable
            println!("{}", x);
                        ^
        note: previous borrow of `x` occurs here; the mutable borrow prevents
        subsequent moves, borrows, or modification of `x` until the borrow ends
                let y = &mut x;
                            ^
        note: previous borrow ends here
        fn main() {
        }

   意思就是说呢，你x的资源不是借给y了吗？人家还没用完（y没有超出其作用域），东西都不在你这，你怎么用？


7. 解引用：

  *a  获取变量的实际值